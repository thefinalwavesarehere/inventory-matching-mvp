// Prisma schema for Inventory Matching System
// Revolutionary Rebuild - Following Spec Requirements
// Database: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Users & Authentication
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String?  // For credentials auth
  role         Role     @default(REVIEWER)
  sessions     Session[]
  auditLogs    AuditLog[]
  matchDecisions MatchCandidate[] @relation("DecidedBy")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("users")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("sessions")
  @@index([userId])
  @@index([token])
}

enum Role {
  ADMIN
  MANAGER
  REVIEWER
  UPLOADER
}

/// Projects & Files
model Project {
  id           String   @id @default(cuid())
  name         String
  description  String?
  files        File[]
  importRuns   ImportRun[]
  inventoryItems InventoryItem[]
  supplierItems SupplierItem[]
  storeItems   StoreItem[]
  interchanges Interchange[]
  matchCandidates MatchCandidate[]
  auditLogs    AuditLog[]
  columnMappings FileColumnMapping[]
  vendorActionRules VendorActionRule[]
  activityLogs ActivityLog[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("projects")
}

model File {
  id           String   @id @default(cuid())
  projectId    String
  project      Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  kind         FileKind
  originalName String
  storageKey   String   // path or S3 key
  sizeBytes    Int
  uploadedById String?
  status       FileStatus @default(QUEUED)
  parsedAt     DateTime?
  rowCount     Int?
  importRuns   ImportRun[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("files")
  @@index([projectId])
  @@index([kind])
  @@index([status])
}

enum FileKind {
  ERIC        // eric.xlsx (canonical metadata: partNumber, description, price)
  ARNOLD      // arnold.xlsx (partNumber, totalLastUsage, cost)
  INTERCHANGE // interchange.xlsx (theirPN <-> ourPN)
  SUPPLIER    // cq file.xlsx (supplier/company inventory)
  STORE       // inventoryinforeport.xls (store being purchased)
}

enum FileStatus {
  QUEUED
  PARSING
  PARSED
  FAILED
}

enum FileTypeForMapping {
  STORE_INVENTORY
  SUPPLIER_CATALOG
  LINE_CODE_INTERCHANGE
  PART_NUMBER_INTERCHANGE
}

model ImportRun {
  id           String   @id @default(cuid())
  projectId    String
  project      Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  fileId       String
  file         File     @relation(fields: [fileId], references: [id], onDelete: Cascade)
  startedAt    DateTime @default(now())
  finishedAt   DateTime?
  status       ImportStatus @default(RUNNING)
  error        String?
  rowsProcessed Int?
  createdAt    DateTime @default(now())

  @@map("import_runs")
  @@index([projectId])
  @@index([fileId])
  @@index([status])
}

enum ImportStatus {
  RUNNING
  SUCCEEDED
  FAILED
}

/// Canonical inventory (Eric + Arnold collapse here)
model InventoryItem {
  id             String   @id @default(cuid())
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  partNumber     String   // canonical PN
  description    String?
  price          Decimal? @db.Decimal(10, 2) // from Eric
  cost           Decimal? @db.Decimal(10, 2) // from Arnold
  totalLastUsage Int?     // from Arnold
  // normalized fields
  partNumberNorm String   @db.Text
  brand          String?
  lineCode       String?
  rawData        Json?    // Store original row data
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([projectId, partNumber])
  @@map("inventory_items")
  @@index([projectId, partNumberNorm])
  @@index([lineCode])
}

/// Supplier items (CarQuest)
model SupplierItem {
  id             String   @id @default(cuid())
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  supplier       String   // e.g., "CarQuest"
  partNumber     String
  partFull       String?  // Full part identifier (e.g., ABC10026A)
  description    String?
  currentCost    Decimal? @db.Decimal(10, 2)
  quantity       Int?
  ytdHist        Int?
  // normalized
  partNumberNorm String   @db.Text
  lineCode       String?
  mfrPartNumber  String?  // Manufacturer part number (after line code extraction)
  canonicalPartNumber String? // Punctuation removed
  brand          String?
  category       String?  // Product category (e.g., "belts", "hoses", "wiring")
  subcategory    String?  // Product subcategory (e.g., "V-belt", "coolant", "connectors")
  rawData        Json?    // Store original row data
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("supplier_items")
  @@index([canonicalPartNumber])
  @@index([lineCode, mfrPartNumber])
  @@index([projectId, supplier])
  @@index([projectId, partNumberNorm])
  @@index([lineCode])
  @@index([partFull])
  @@index([category])
  @@index([subcategory])
}

/// Store report items (store being purchased)
model StoreItem {
  id             String   @id @default(cuid())
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  partNumber     String
  partFull       String?  // Full part identifier
  description    String?
  currentCost    Decimal? @db.Decimal(10, 2)
  quantity       Int?
  rollingUsage   Int?     // Rolling 12 months usage
  // normalized
  partNumberNorm String   @db.Text
  lineCode       String?
  mfrPartNumber  String?  // Manufacturer part number (after line code extraction)
  canonicalPartNumber String? // Punctuation removed
  brand          String?
  category       String?  // Product category (e.g., "belts", "hoses", "wiring")
  subcategory    String?  // Product subcategory (e.g., "V-belt", "coolant", "connectors")
  rawData        Json?    // Store original row data
  matchCandidates MatchCandidate[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("store_items")
  @@index([canonicalPartNumber])
  @@index([lineCode, mfrPartNumber])
  @@index([projectId, partNumberNorm])
  @@index([lineCode])
  @@index([partFull])
  @@index([category])
  @@index([subcategory])
}

/// Interchange (deterministic hints)
model Interchange {
  id             String   @id @default(cuid())
  projectId      String
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  oursPartNumber String
  theirsPartNumber String
  source        String?   // "client", "vendor", "file", "ai_confirmed"
  confidence    Float     @default(1.0)
  createdAt     DateTime  @default(now())

  @@map("interchanges")
  @@index([projectId, oursPartNumber])
  @@index([projectId, theirsPartNumber])
  @@unique([projectId, oursPartNumber, theirsPartNumber])
}

/// Matching
model MatchCandidate {
  id               String   @id @default(cuid())
  projectId        String
  project          Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  storeItemId      String
  storeItem        StoreItem @relation(fields: [storeItemId], references: [id], onDelete: Cascade)
  targetType       TargetType // INVENTORY or SUPPLIER
  targetId         String     // FK to InventoryItem or SupplierItem (stringly typed)
  method           MatchMethod
  confidence       Float      // 0..1
  features         Json       // signals used (scores, tokens, pn edits)
  matchStage       Int?       // Which stage found this match (0-4)
  rulesApplied     Json?      // Array of rule IDs used
  costDifference   Decimal?   @db.Decimal(10, 2)
  costSimilarity   Float?     // 0-1
  transformationSignature String? // For pattern detection
  status           MatchStatus @default(PENDING)
  decidedById      String?
  decidedBy        User?      @relation("DecidedBy", fields: [decidedById], references: [id], onDelete: SetNull)
  decidedAt        DateTime?
  note             String?
  // Excel review fields
  vendorAction     VendorAction @default(NONE)
  correctedSupplierPartNumber String?
  reviewSource     ReviewSource?
  reviewedAt       DateTime?
  reviewedByUserId String?
  enrichmentData   EnrichmentData[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@map("match_candidates")
  @@index([projectId])
  @@index([storeItemId])
  @@index([targetType, targetId])
  @@index([status])
  @@index([method])
  @@index([confidence])
  @@index([matchStage])
  @@index([transformationSignature])
}

enum TargetType {
  INVENTORY
  SUPPLIER
}

enum MatchMethod {
  INTERCHANGE
  EXACT_NORM
  EXACT_NORMALIZED
  LINE_PN
  DESC_SIM
  FUZZY
  FUZZY_SUBSTRING
  AI
  WEB_SEARCH
  RULE_BASED
}

enum MatchStatus {
  PENDING
  CONFIRMED
  REJECTED
}

enum VendorAction {
  NONE
  LIFT
  REBOX
  UNKNOWN
  CONTACT_VENDOR
}

enum ReviewSource {
  UI
  EXCEL
}

/// Vendor Action Rules for automatic tagging
model VendorActionRule {
  id                  String       @id @default(cuid())
  projectId           String?      // Null = Global rule, Present = Project-specific rule
  project             Project?     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  supplierLineCode    String       // Supplier line code (e.g., "GATES", "PICO")
  categoryPattern     String       // Category pattern (* for wildcard)
  subcategoryPattern  String       // Subcategory pattern (* for wildcard)
  action              VendorAction // Action to apply
  active              Boolean      @default(true)
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt

  @@map("vendor_action_rules")
  @@index([supplierLineCode])
  @@index([active])
  @@index([projectId])
}

/// Match History: Accepted matches for learning
model AcceptedMatchHistory {
  id                  String   @id @default(cuid())
  projectId           String
  storePartNumber     String
  supplierPartNumber  String
  supplierLineCode    String?
  createdAt           DateTime @default(now())

  @@map("accepted_match_history")
  @@index([projectId])
  @@index([storePartNumber, supplierPartNumber])
  @@index([supplierLineCode])
}

/// Match History: Rejected matches for learning
model RejectedMatchHistory {
  id                  String   @id @default(cuid())
  projectId           String
  storePartNumber     String
  supplierPartNumber  String
  supplierLineCode    String?
  createdAt           DateTime @default(now())

  @@map("rejected_match_history")
  @@index([projectId])
  @@index([storePartNumber, supplierPartNumber])
  @@index([supplierLineCode])
}

/// Line Code Interchange: Maps source line codes to target line codes
model LineCodeInterchange {
  id              String   @id @default(cuid())
  projectId       String?  // Nullable: null = global rule, value = project-specific
  sourceLineCode  String   // Source supplier line code (e.g., "GATES")
  targetLineCode  String   // Target supplier line code to use instead
  priority        Int      @default(0) // Higher priority rules take precedence
  active          Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("line_code_interchange")
  @@index([sourceLineCode, active])
  @@index([projectId])
  @@index([priority])
}

/// Part Number Interchange: Direct part number mappings
model PartNumberInterchange {
  id                      String   @id @default(cuid())
  projectId               String   // Project-specific interchange
  sourceSupplierLineCode  String   // Source supplier line code
  sourcePartNumber        String   // Source part number
  targetSupplierLineCode  String   // Target supplier line code
  targetPartNumber        String   // Target part number
  priority                Int      @default(0) // Higher priority rules take precedence
  active                  Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@map("part_number_interchange")
  @@index([sourceSupplierLineCode, sourcePartNumber, active])
  @@index([projectId])
  @@index([priority])
}

/// Data enrichment for matched parts
model EnrichmentData {
  id          String   @id @default(cuid())
  matchId     String
  match       MatchCandidate @relation(fields: [matchId], references: [id], onDelete: Cascade)
  fieldName   String   // 'description' | 'price' | 'box_size' | 'qty_per_box' | etc.
  fieldValue  String
  source      String   // 'supplier' | 'web_search' | 'manual' | 'ai'
  confidence  Float    @default(1.0)
  createdAt   DateTime @default(now())

  @@map("enrichment_data")
  @@index([matchId])
  @@index([fieldName])
}

/// Audit logging
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  entity    String   // e.g., "MatchCandidate", "File"
  entityId  String
  action    String   // "UPLOAD", "DECIDE_MATCH", "EXPORT", "AUTO_CONFIRM", "AUTO_REJECT"
  meta      Json
  createdAt DateTime @default(now())

  @@map("audit_logs")
  @@index([userId])
  @@index([projectId])
  @@index([entity, entityId])
  @@index([action])
  @@index([createdAt])
}

/// Matching progress tracking
model MatchingProgress {
  id                    String   @id @default(cuid())
  projectId             String   @unique
  // Standard matching (exact + fuzzy)
  standardCompleted     Boolean  @default(false)
  standardBatchOffset   Int      @default(0)
  standardTotalItems    Int      @default(0)
  standardProcessed     Int      @default(0)
  standardLastRun       DateTime?
  // AI matching
  aiCompleted           Boolean  @default(false)
  aiBatchOffset         Int      @default(0)
  aiTotalItems          Int      @default(0)
  aiProcessed           Int      @default(0)
  aiLastRun             DateTime?
  // Web search matching
  webSearchCompleted    Boolean  @default(false)
  webSearchBatchOffset  Int      @default(0)
  webSearchTotalItems   Int      @default(0)
  webSearchProcessed    Int      @default(0)
  webSearchLastRun      DateTime?
  // Overall status
  currentStage          String   @default("UPLOAD") // UPLOAD, STANDARD, AI, WEB_SEARCH, REVIEW, COMPLETE
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("matching_progress")
}

/// Line code mappings (client line codes â†’ manufacturers)
model LineCodeMapping {
  id                String   @id @default(cuid())
  clientLineCode    String
  manufacturerName  String?
  arnoldLineCode    String?
  confidence        Float    @default(1.0)
  source            String   // 'manual', 'learned', 'interchange'
  notes             String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([clientLineCode, manufacturerName])
  @@map("line_code_mappings")
  @@index([clientLineCode])
  @@index([arnoldLineCode])
}

/// Enhanced interchange mappings
model InterchangeMapping {
  id                    String   @id @default(cuid())
  // Competitor/client side
  competitorLineCode    String?
  competitorPartNumber  String?
  competitorFullSku     String
  competitorManufacturer String?
  // Arnold side
  arnoldLineCode        String?
  arnoldPartNumber      String?
  arnoldFullSku         String
  // Metadata
  confidence            Float    @default(1.0)
  source                String   // 'file_import', 'learned', 'manual'
  notes                 String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("interchange_mappings")
  @@index([competitorFullSku])
  @@index([arnoldFullSku])
  @@index([competitorLineCode, competitorPartNumber])
}

/// Learned rules from approved patterns
model MatchingRule {
  id              String   @id @default(cuid())
  ruleType        String   // 'punctuation', 'line_code_map', 'cost_tolerance', 'pattern'
  // Rule definition
  pattern         Json     // e.g., {"from": "/", "to": "-", "line_code": "PPG"}
  transformation  String   // Human-readable description
  // Scope
  scope           String   // 'global', 'manufacturer', 'client', 'project'
  scopeId         String?  // ID of manufacturer/client/project if scoped
  // Metadata
  confidence      Float    @default(1.0)
  usageCount      Int      @default(0)
  approvalCount   Int      @default(0)
  rejectionCount  Int      @default(0)
  createdBy       String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  active          Boolean  @default(true)

  @@map("matching_rules")
  @@index([ruleType, active])
  @@index([scope, scopeId])
}

/// Track match rates by stage
model MatchStageMetrics {
  id                String   @id @default(cuid())
  projectId         String
  jobId             String?
  // Stage info
  stageNumber       Int      // 0=preprocessing, 1=deterministic, 2=fuzzy, 3=AI, 4=web
  stageName         String
  // Metrics
  itemsProcessed    Int
  matchesFound      Int
  matchRate         Float
  avgConfidence     Float?
  processingTimeMs  Int
  apiCostUsd        Float    @default(0)
  // Breakdown
  rulesApplied      Json?    // Which rules were used
  createdAt         DateTime @default(now())

  @@map("match_stage_metrics")
  @@index([projectId, stageNumber])
  @@index([jobId])
}

/// Matching jobs for background processing
model MatchingJob {
  id                    String   @id @default(cuid())
  projectId             String
  createdBy             String?
  // Status
  status                String   // 'pending', 'processing', 'completed', 'failed', 'cancelled'
  currentStage          Int?     // 0-4
  currentStageName      String?
  // Progress
  totalItems            Int?
  processedItems        Int      @default(0)
  progressPercentage    Float    @default(0)
  // Results
  matchesFound          Int      @default(0)
  matchRate             Float    @default(0)
  // Timing
  startedAt             DateTime?
  completedAt           DateTime?
  estimatedCompletion   DateTime?
  // Configuration
  config                Json?    // Which stages to run, thresholds, etc.
  // Metrics
  metrics               Json?    // Full MatchingRunMetrics object
  // Error handling
  errorMessage          String?
  retryCount            Int      @default(0)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("matching_jobs")
  @@index([projectId, status])
  @@index([createdBy])
  @@index([status, createdAt])
}

/// Project settings (thresholds, AI toggle, etc.)
model ProjectSettings {
  id                String   @id @default(cuid())
  projectId         String   @unique
  autoConfirmMin    Float    @default(0.92)
  reviewBandMin     Float    @default(0.65)
  autoRejectMax     Float    @default(0.40)
  aiEnabled         Boolean  @default(false)
  normalizationRules Json?   // Brand/line regex patterns
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@map("project_settings")
}

/// Epic A5: Flexible column mapping for CSV uploads
/// Allows users to map arbitrary CSV headers to system fields
model FileColumnMapping {
  id            String              @id @default(cuid())
  projectId     String
  project       Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  fileType      FileTypeForMapping  // Which type of file this mapping applies to
  columnName    String              // The header name in the user's file (e.g., "Part #")
  semanticRole  String              // Our internal field name (e.g., "part_number", "line_code")
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@unique([projectId, fileType, semanticRole])
  @@map("file_column_mappings")
  @@index([projectId, fileType])
}

/// Epic B2: User Accounts, Authentication & Activity Logging
/// UserProfile syncs with Supabase auth.users table

enum UserRole {
  ADMIN
  EDITOR
  VIEWER
}

model UserProfile {
  id                  String        @id // Must match Supabase auth.users.id (UUID)
  email               String        @unique
  fullName            String?       @map("full_name")
  role                UserRole      @default(EDITOR)
  isApproved          Boolean       @default(false) @map("is_approved")
  createdAt           DateTime      @default(now()) @map("created_at")
  updatedAt           DateTime      @updatedAt @map("updated_at")
  
  // Relations
  activityLogs        ActivityLog[]
  
  @@map("user_profiles")
  @@index([email])
  @@index([role])
  @@index([isApproved])
}

model ActivityLog {
  id          String    @id @default(cuid())
  projectId   String?   @map("project_id")
  project     Project?  @relation(fields: [projectId], references: [id], onDelete: SetNull)
  userId      String    @map("user_id")
  user        UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)
  action      String    // e.g., "USER_PROMOTED", "BULK_REJECT", "RULE_CREATED"
  details     Json      // Additional context (e.g., { matchIds: [...], status: "ACCEPTED" })
  ipAddress   String?   @map("ip_address")
  createdAt   DateTime  @default(now()) @map("created_at")
  
  @@map("activity_logs")
  @@index([userId])
  @@index([projectId])
  @@index([action])
  @@index([createdAt])
}
